# 面向对象的设计模式

* [设计的基石](#设计的基石)
* [创建型模式](#创建型模式)
* [结构型模式](#结构型模式)
* [行为型模式](#行为型模式)
* [六大框架设计原则](#六大框架设计原则)

<a name="设计的基石"></a>
### 设计的基石 ###

- 封装 -- 对象间的联系  
- 继承 -- 对象间的层次  
- 多态 -- 对象间的差异 

### 框架和设计模式 ###

- 框架：整个或部分系统的可重用设计，表现为一组抽象构件及构件实例键交互的方法。可被应用开发者定制的应用骨架。 
- 设计模式：是针对某种环境中反复出现的问题以及解决该问题的方案的描述，比框架更抽象。
- 框架是软件，设计模式是软件的知识。

<a name="创建型模式"></a>
### 创建型模式 ###

> 单例模式  

	确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。

	涉及到一个单一的类，该类负责创建自己的对象，同时确保只有一 个对象被创建。
	这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

	单例模式的三种形式：
		1. 饿汉式：
				在类加载时，就进行对象的实例化。
				即在类中定义一个私有的静态方法getInstance()进行实例化对象。

				public static Sort sort = new Sort();

			    public static Sort getInstance(){
			        return sort;
			    }
	
		2. 懒汉式：
				类的构造函数是私有的，在类加载时不会实例化，而是在第一次调用时私有方法getInstance()才实例化。懒加载模式。
				getInstance()在多线程情况下需要加锁，保证只有一个实例被产生。

				private static Sort sort = null;

			    public static Sort getInstance(){
			        if (sort == null) {
			            synchronized(Sort.class){
			                if(sort == null){
			                    sort = new Sort();
			                }
			            }
			        }
			        return sort;
			    }
	
		3. 双重锁式：
				先判断实例是否存在，存在即返回，不存在则对类加锁【synchronize】再次判断实例是否存在，不存在则实例化对象。

	如果希望在系统中某个类的对象只能存在一个，单例模式是最好的选择。
	单例模式的构造函数必须是private，同时必须提供一个全局访问点。

> 工厂模式  

	定义：
		定义一个用于创建对象的接口，让子类决定实例化哪一个类。将实例化的决定权交给子类来完成。
		即子类只需要确定实例化哪个类，而不用关心如何实例化。
		比如去买车，用户只需要向工厂决定买什么车，不用关心车怎么生产出来的，由而是由工厂将车生产出来【实例化】交给客户。

	单一抽象产品类，单一具体工厂类。
	提供一个简单的决策类，根据条件生产产品。


> 抽象工厂模式  

	定义：
		为创建一系列相关或相互依赖对象提供一个的接口，而无需指定它们具体的类。

	多个抽象产品类，多个具体工厂类。即产品族【接口】和工厂族【接口】。
	客户在产品族中决定买什么车，就有工厂族中的某个工厂来生产。
	即工厂不止一个，将工厂抽象出来，再派生不同功能的具体工厂。
	
	抽象工厂模式的角色：

		1. 抽象工厂：
			核心角色，和应用逻辑无关。是具体工厂必须实现的接口或必须继承的父类。

		2. 具体工厂：
			该角色直接在客户端的调用下创建产品的实例。和应用逻辑有关。

		3. 抽象产品：
			该角色是具体产品继承的父类或实现的接口。一般由抽象类或接口来实现。

		4. 具体产品：
			抽象工厂模式所创建的任何产品对象都是某一个具体产品的实例，和应用逻辑有关。

> 建造者模式  

	定义：
		使用多个简单的对象一步一步构建成一个复杂的对象。保证流程的一致性。
		比如建房子。流程都是一样的，但流程中的多个部件可以是不同的。

	实现步骤：
		1. 定义一个产品类 product；
			要创建的复杂对象。

		2. 定义抽象建造者 Builder；
			为创建复杂对象的各个部件指定抽象接口。
	
		3. 定义具体建造者 ConcreteBuilder；
			实现抽象建造者接口，针对业务逻辑具体化复杂对象的各部分的创建。
			在建造过程完成后，提供产品的实例。
	
		4. 定义一个统一的调度类 director。
			负责调用具体建造者来创建复杂对象的各个部件，保证对象个部分完整创建或者按某种顺序创建。

> 原型模式  

	用于创建重复的对象，同时又能保证性能。

<a name="结构型模式"></a>
### 结构型模式 ###

> 代理模式 【Proxy 】

	特点：一个类代表另一个类的功能。

> 适配器模式 【Adapter】

	特点：
		将一个类的接口转换成客户端的一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

	关系：
		适配接口和被适配接口没有层次关系。

	关键代码：
		适配器继承或依赖已有的对象，实现想要的目标接口。

	例子：
		字节流转换为字符流【inputStreamReader】,springmvc【@Response】

> 装饰者模式 【Decorator 】
	
	特点：
		装饰者继承被装饰者，并对其接口进行动态的添加或者覆盖；

	关系：
		装饰者和被装饰者接口是继承及多态的层次关系；

	关键代码： 
		1、Component 类充当抽象角色，不应该具体实现。 
		2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。

	例子：java IO

	使用场景： 
		1、扩展一个类的功能。 
		2、动态增加功能，动态撤销。

> 享元模式 【Flyweight 】

	特点：
		共享对象状态，减少重复创建对象

	关系：	
		享元对象缓存共享实体

	关键代码：
		用 HashMap 存储这些对象。

	例子：ThreadLocal、Integer缓存、String intern

	主要解决：
		在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。

> 组合模式 【Composite】

	特点：
		是用于把一组相似的对象当作一个单一的对象。
		执行组合对象是如同执行器元素对象。
		组合模式依据树形结构来组合对象，用来表示部分以及整体层次。

	关键代码：
		树枝内部组合该接口，并且含有内部属性 List，里面放 Component。

	关系：
		组合对象和被组合对象可能是相同类型。

	例子：集合类

> 外观/门面模式 【Facade 】

	特点： 
		简化接口，聚合子系统的实现。
		隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。	
		为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

	关键代码：
		在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。

	何时使用： 
		1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个"接待员"即可。 
		2、定义系统的入口。

	例子：tomcat、DispatcherServlet

<a name="行为型模式"></a>
### 行为型模式 ###

> 责任链模式 【Chain of Responsibility】

	概念：
		为请求创建了一个接收者对象的链；
		这种模式给予请求的类型，对请求的发送者和接收者进行解耦。
		每个责任节点都有自己的处理逻辑。

	关键代码：
		Handler 里面聚合它自己，在 HanleRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。

	主要解决：
		职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。

	例子：servlet的Filter链 【chain.doFilter(request,response);】 、 java logging

> 拦截器模式 【Filter 】

	例子：AOP

> 观察者模式 【Observer 】

	概念：
		当一个对象被修改时，则会自动通知它的依赖对象【发布、订阅】。

	何时使用：
		一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者、订阅者对象）都将得到通知，进行广播通知。

	关键代码：
		在抽象类里有一个 ArrayList 存放观察者们。

<a name="框架设计原则"></a>
### 框架设计原则 ###

> 1、单一职责原则  

	原则：
		一个类只负责一项职责。

	优点：

		可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；
		提高类的可读性，提高系统的可维护性；
		变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。

> 2、里式替换原则  

	能用父类表示的地方，都可以使用其子类进行替换，且换成子类也不会出现任何错误或异常，而使用者也无需知道是父类还是子类，但反过来则不成立。可以理解为多态。
	子类可以扩展父类的功能，但不能改变父类原有的功能。
	当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。

	总结：
	 	1. 子类必须完全实现父类的抽象方法，但不能覆盖父类的非抽象方法；
	    2. 子类中可以增加自己特有的方法；
	    3. 当子类的方法重载父类的方法时，方法的前置条件(即方法的形参)要比父类方法的输入参数要更宽松；
	    4. 当子类的方法实现父类的抽象方法时，方法的后置条件(即方法的返回值)要比父类更严格。

	优点：
		1. 提高代码的重用性，子类拥有父类的方法和属性；
		2. 提高代码的可扩展性，子类可形似于父类，但异于父类，保留自我的特性；
	
	缺点：
		1. 继承是侵入性的，只要继承就必须拥有父类的所有方法和属性，在一定程度上约束了子类，降低了代码的灵活性；
		2. 增加了耦合，当父类的常量、变量或者方法被修改了，需要考虑子类的修改，所以一旦父类有了变动，很可能会造成非常糟糕的结果，要重构大量的代码。

> 3、依赖倒置原则  

	定义：
		高层模块不应该依赖低层模块，二者都应该依赖其抽象；
		抽象不应该依赖细节；
		细节应该依赖抽象。
		由于一般编程都是抽象依赖于细节，而该设计原则是倒置过来，所以取名为依赖倒置。

	原则：面向接口编程。
		抽象指的是 接口或抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。

	由于抽象的变动会引起实现类的变动，所以要保证抽象的稳定性，定义好了规范就尽量不要变动，具体的操作交给底层模块的实现类来完成。实现细节依赖于抽象。
	即要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。

	注意：

		1. 在代码中传递参数或关联关系时，尽量引用高层的抽象层类，即使用接口和抽象类进行变量声明、参数类型声明、方法返回类型声明以及数据类型的转换；
		2. 当一个对象和其他对象有依赖关系时，可以利用依赖注入的方法将类之间进行解耦，主要有：构造注入、Set方法注入和接口注入；
		3. 开闭是原则，里氏是基础，依赖倒置是手段；
		4. 低层模块尽量都要有抽象类或接口，或者两者都有；
		5. 变量的声明类型尽量是抽象类或接口；
		6. 使用继承时遵循里氏替换原则。

> 4、接口隔离原则  

	原则： 
		客户端不应该依赖它不需要的接口；
		一个类对另一个类的依赖应该建立在最小的接口上。

	建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。
	但是如果接口过小，就会造成接口数量过多，是设计复杂化，所以要适度。
	为依赖接口的类定制服务，只暴露给调用的类它需要的方法，不需要的方法就隐藏起来，建立最小依赖关系。

> 5、迪米特原则  

	迪米特原则，也叫最少知识原则。
	一个对象应该对其他对象有最少的了解，这样当引用的其他对象产生变化时，对该对象的影响也就最下。

	通俗的讲：一个类对自己需要耦合或调用的类知道的最少，你(被耦合或调用的类)的内部是如何复杂和我没有关系，我就知道你提供的public方法，我只调用这些方法，其它的我不关心。

	一个软件实体应当尽量少的与其他软件实体之间发生相互作用，使得系统功能模块相对独立。作用越小，耦合就越小。
	降低依赖，降低耦合，低耦合，高内聚。

	如果两个类不必要直接通信，那么这两个类就不应该发生直接的相互作用。
	如果其中的一个类需要调用另一个类的某个方法，可以通过第三方中介类来转发这个调用，以此降低耦合。
	即要求只和朋友说话，不要和陌生人说话。

	缺点：
		会产生大量的中介类，这些类的目的只是用来转发类之间的相互调用，增加了类的复杂度。

> 6、开闭原则【OCP】
	
	对扩展开放，对修改关闭。
	可以创建模块类的扩展类，但不可以修改模块类的源代码。
	
	使用抽象基类来实现。
	由于模块依赖于一个固定的抽象基类，所以不会修改抽象基类，但是可以从该抽象基类中派生出更多的扩展类。

	如何使用：
		抽象约束：
			1. 通过接口或者抽象类约束扩展，对扩展进行辩解限定，不允许出现在接口或者抽象类中不存在的public方法。
			2. 参数类型、引用对象尽量使用接口或者抽象类，而不是实现类。
			3. 抽象层尽量保持稳定，一旦确定就不允许修改。

		元数据控制模块行为：
			1. 元数据就是用来描述环境和数据的数据。通俗而言就是配置参数，参数可以从文件中获取，也可以从数据库中获取。
			2. Spring 容器就是一个典型的元数据控制模块行为的例子--控制反转IOC。

		封装变化：
			1. 将相同的变化封装到一个接口或者抽象类中；
			2. 将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。

		制定项目章程：
			对项目而言，约定优于配置。

> 用抽象构建框架，用实现扩展细节的注意事项而已：  

	单一职责原则 -- 实现类要职责单一；
	里氏替换原则 -- 不要破坏继承体系；
	依赖倒置原则 -- 要面向接口编程；
	接口隔离原则 -- 在设计接口的时候要精简单一；
	迪米特法则   -- 要降低耦合；

	开闭原则是总纲，要对扩展开放，对修改关闭。

> 单一职责原则和接口隔离原则的区别

	1. 单一职责原则注重的是职责；接口隔离原则注重对接口依赖的隔离。
	2. 单一职责原则主要是约束类的单一性，其次才是接口和方法，它针对的程序中的实现和细节；接口隔离原则约束接口的单一性，主要针对抽象，针对程序整体框架的构建。 
	3. 一个单一的类可能需要多个单一的接口来实现。
	