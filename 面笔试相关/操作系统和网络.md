### 操作系统 ###

> 进程和线程的区别。

	一个进程可以包含多条线程。

> 死锁的必要条件，怎么处理死锁。

	产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。

		1. 互斥条件：一个资源每次只能被一个进程使用。独木桥每次只能通过一个人。

		2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。乙不退出桥面，甲也不退出桥面。

		3. 不剥夺条件: 进程已获得的资源，在未使用完之前，不能强行剥夺。甲不能强制乙退出桥面，乙也不能强制甲退出桥面。

		4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。如果乙不退出桥面，甲不能通过，甲不退出桥面，乙不能通过。

### TCP/IP ###

	TCP协议对应于传输层，而HTTP协议对应于应用层。

> TCP与UDP的区别。

	TCP
		TCP 是传输控制协议的缩写，它保障了两个应用程序之间的可靠通信。
		通常用于互联网协议，被称 TCP / IP。
		传输控制协议，提供的是面向连接、可靠的字节流传输层的通讯协议。


	UDP
		UDP 是用户数据报协议的缩写，一个无连接的协议。
		提供了应用程序之间要发送的数据的数据包。
		用户数据报协议，是一个简单的面向数据报的传输层的通讯协议。

> TCP的三次握手与四次挥手过程

	TCP建立连接需要三次握手：

		1. 建立连接时，客户端发送syn包（syn=j）到服务器，并进入 SYN_SENT 状态，等待服务器确认；
				SYN：同步序列编号（Synchronize Sequence Numbers）。

		2. 服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN + ACK 包，此时服务器进入 SYN_RECV 状态【半连接状态】；
		
		3. 客户端收到服务器的 SYN + ACK 包，向服务器发送确认包ACK(ack=k+1），此包发送完毕。
			客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

		ACK起应答作用，而SYN起同步作用。

	TCP断开连接需要四次挥手：

		1. 客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。
			表示客户端没有数据进行发送了，可以关闭连接了
		
		2. 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。
			发送ACK表示已经收到信息
		
		3. 服务器B关闭与客户端A的连接，发送一个FIN给客户端A。
			发送FIN 表示已经没有数据进行传输了，可以关闭了

		4. 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。
			客户端收到，执行关闭，服务端也被动关闭。

	服务端的 ACK 和 FIN 是分开发送的，发送ACK 时并不代表服务端没有数据进行发送了，只有发送了FIN 才表示没有数据发送。

> TIME_WAIT 和 CLOSE_WAIT 的区别。

	TIME_WAIT状态就是用来重发可能丢失的ACK报文。 
	TIME_WAIT 表示主动关闭，CLOSE_WAIT 表示被动关闭。

> Http的报文结构

	HTTP报文：
		它是HTTP应用程序之间发送的数据块。
		这些数据块以一些文本形式的元信息开头，这些信息描述了报文的内容及含义，后面跟着可选的数据部分。
		这些报文都是在客户端、服务器和代理之间流动。

	HTTP报文的流动方向：
		一次HTTP请求，HTTP报文会从“客户端”流到“代理”再流到“服务器”，在服务器工作完成之后，报文又会从“服务器”流到“代理”再流到“客户端”。

	所有的HTTP报文都可以分为两类：请求报文、响应报文。

	结构：起始行、头部、主体。

> Http的状态码含义

	1xx:	信息
	2xx:	响应成功
	3xx:	跳转、重定向
	4xx:	客户端错误
	5xx:	服务端错误

> Http request的几种类型

	1. OPTIONS：允许客户端查看服务器的性能。

	2. HEAD：类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。
	
	3. GET：向特定的资源发出请求。
	
	4. POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。
			数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。
	
	5. PUT：向指定资源位置上传其最新内容。
	
	6. DELETE：请求服务器删除Request-URI所标识的资源。
	
	7. TRACE：回显服务器收到的请求，主要用于测试或诊断。
	
	8. CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。

	GET方法：
		使用GET方法时，查询字符串（键值对）被附加在URL地址后面一起发送到服务器：
		/test/demo_form.jsp?name1=value1&name2=value2
		特点：
		GET请求能够被缓存
		GET请求会保存在浏览器的浏览记录中
		以GET请求的URL能够保存为浏览器书签
		GET请求有长度限制
		GET请求主要用以获取数据
	POST方法：
		使用POST方法时，查询字符串在POST信息中单独存在，和HTTP请求一起发送到服务器：
		POST /test/demo_form.jsp HTTP/1.1
		Host: w3schools.com
		name1=value1&name2=value2
		特点：
		POST请求不能被缓存下来
		POST请求不会保存在浏览器浏览记录中
		以POST请求的URL无法保存为浏览器书签
		POST请求没有长度限制

	get 、post请求比较:
			1. 从安全性看get<post。
				get提交的数据会在浏览器的地址栏显示。
			2. 从提交的内容大小看get<post。
				get提交的数据不能大于2K，而post提交的数据理论上不受限制，但是实际编程中建议不要大于64K。
			3. 从请求响应速度看get>post。
				get请求服务器立即处理请求，而post请求可能形成一个队列请求。

> Http1.1和Http1.0的区别

	HTTP/1.0和HTTP/1.1都把TCP作为底层的传输协议。

	HTTP 1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理。
			增加host字段
			还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。

	HTTP 1.0 规定浏览器与服务器只保持短暂的连接。
		浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。

	一次完整的请求过程：

　　		1. 域名解析

　　		2. 建立TCP连接，三次握手

　　		3. Web浏览器向Web服务端发送HTTP请求报文

　　		4. 服务器响应HTTP请求

　　		5. 浏览器解析HTML代码，并请求HTML代码中的资源（JS，CSS，图片）（这是自动向服务器请求下载的）

　　		6. 浏览器对页面进行渲染呈现给客户

　　		7. 断开TCP连接

> Http怎么处理长连接

	在HTTP1.0和HTTP1.1协议中都有对长连接的支持。
	其中HTTP1.0需要在request中增加"Connection：keep-alive" header才能够支持，而HTTP1.1默认支持.

	http1.0请求与服务端的交互过程:

		1. 客户端发出带有包含一个header："Connection：keep-alive"的请求；

		2. 服务端接收到这个请求后，根据http1.0和"Connection：keep-alive" 判断出这是一个长连接，就会在response的header中也增加"Connection：keep-alive"，同时不会关闭已建立的tcp连接；

		3. 客户端收到服务端的response后，发现其中包含"Connection：keep-alive"，就认为是一个长连接，不关闭这个连接。
			并用该连接再发送request。

	http1.1请求与服务端的交互过程:

		1. 客户端发出http1.1的请求；

		2. 服务端收到http1.1后就认为这是一个长连接，会在返回的response设置"Connection： keep-alive"，同时不会关闭已建立的连接；

		3. 客户端收到服务端的response后，发现其中包含"Connection：keep-alive"，就认为是一个长连接，不关闭这个连接。
			并用该连接再发送request。

> Cookie 与 Session 的作用原理

	Cookie 保存在客户端浏览器
	Session 保存在服务端。默认有效时间30分。
	Cookie可以让服务端跟踪每个客户端的访问，但是每次客户端的访问都必须传回这些Cookie，如果Cookie很多，则无形的增加了客户端与服务端的数据传输量，
	而Session则很好地解决了这个问题，同一个客户端每次和服务端交互时，将数据存储通过Session到服务端，不需要每次都传回所有的Cookie值，而是传回一个ID。
	每个客户端第一次访问服务器生成的唯一的ID，客户端只要传回这个ID就行了，这个ID通常为NAME为JSESSIONID的一个Cookie。
	这样服务端就可以通过这个ID，来将存储到服务端的KV值取出了。

> C/S模式下使用socket通信，几个关键函数
	
	1. socket	创建一个套接字用于通信
	2. bind		绑定一个本地地址到套接字，将本地的端口同socket返回的文件描述符捆绑在一起
	3. listen	将套接字用于监听进入的连接
	4. accept	将套接字用于接受进入的连接
	5. connect	建立一个连接至addr所指定的套接字，是客户端用来同服务端连接的。

	bind,listen和accept是服务器端用的函数，accept调用时，服务器端的程序会一直阻塞到有一个客户程序发出了连接。
	
	socket 可以看成是用户进程和内核进程进行通信的网络接口。
	不仅可以用于本机的进程间通信，还可以用于网络上不同主机的进程间通信。
	不同硬件设备间的通信。
	
	总的来说网络程序是由两个部分组成的：客户端和服务器端。
	它们的建立步骤一般是:
		
		服务器端
		socket-->bind-->listen-->accept
		
		客户端
		socket-->connect

> 当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤。

	Dns解析–>端口分析–>tcp请求–>服务器处理请求–>服务器响应–>浏览器解析—>链接关闭

> HTTPS 的加密方式是什么，讲讲整个加密解密流程。

	加密方式是tls/ssl，底层是通过对称算法，非对称，hash算法实现 
	1. 客户端发起HTTPS请求 
	2. 服务端的配置 
	3. 传送证书 
	4. 客户端解析证书
	5. 传送加密信息 
	6. 服务段解密信息 
	7. 传输加密后的信息 
	8. 客户端解密信息 
	
> 线上系统突然变得异常缓慢，你如何查找问题。

	逐级排查（网络，磁盘，内存，cpu），数据库，日志，中间件等也可通过监控工具排查。



