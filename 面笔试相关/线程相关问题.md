### 线程相关问题 ###

> Java内存模型 -- Java Memory Model,JMM

	主要目标：定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。

	1. 主内存【共享】
		规定所有的变量都存储在主内存中。

	2. 工作内存【私有】
		每个线程都有自己的工作内存，用于存放被该线程使用到的变量的主内存副本。
		线程对变量的所有操作都必须在工作内存中进行，不能直接读写主内存的变量。
	
	不同线程间无法直接访问对方的工作内存中的变量，只能通过主内存来完成工作内存间的变量的传递。

![](images/jvm2.png) 

![](images/jvm3.png)

	主内存主要对应于Java 堆中对象的实例数据部分，工作内存则对应于虚拟机栈中的部分区域。
	或者说，
	主内存就是硬件的内容，工作内存则存储于寄存器和高速缓存中。

	内存间交互操作【JMM定义了八种操作来完成】：
		
		1. lock【加锁】
			作用于主内存的变量，把一个变量标识为一个线程独占的状态。

		2. unlock【解锁】
			作用于主内存的变量，把处于加锁状态的变量释放，这样才可以被其他线程加锁。
			
		3. read【读取】
			作用于主内存的变量，把变量的值从主内存传到线程的工作内存中。

		4. load【载入】
			作用于工作内存的变量，将read操作得到的变量值载入工作内存的变量副本中。

		5. use【使用】
			作用于工作内存的变量，将工作内存的一个变量的值传递给执行引擎。

		6. assign【赋值】
			作用于工作内存的变量，将一个从执行引擎接收到的值赋给工作内存的变量。

		7. store【存储】
			作用于工作内存的变量，把工作内存中的一个变量的值传送给主内存。

		8. write【写入】
			作用于主内存的变量，把从store操作获取的变量值写入主内存的变量中。

	【注】
	1. 对一个变量进行 lock 操作前，将会清空工作内存中该变量的值，确保该变量值是从主内存获取到的值；
	2. 对一个变量进行 unlock 操作前，必须先把该变量同步回主内存中【执行store和write操作】。
	3. JMM 要求这八种操作都是原子性的。

> 创建线程的3种方式

	1. 继承 Thread 类
	2. 实现 Runnable 接口
	3. 实现 Callable 接口

> 什么是线程安全

	当多个线程访问一个对象时，不需要进行额外的同步或者协调操作，都可以获取正确的结果，则这个对象就是线程安全的。

> Runnable接口和Callable接口的区别

	Runnable 接口中的 run() 方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；

	Callable 接口中的 call() 方法是有返回值的，是一个泛型，和Future、FutureTask【间接继承Future】配合可以用来获取异步执行的结果。

> wait方法和sleep方法的区别

	1. sleep()方法是属于Thread类中的，而wait()方法，则是属于Object类中的。

	2. 最主要是sleep()方法没有释放锁，而wait()方法释放了锁。

	3. wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用。

	4. sleep()必须捕获异常，而wait，notify和notifyAll不需要捕获异常。

	sleep() 指线程被调用时，占着CPU不工作，形象地说明为“占着CPU睡觉”，此时，系统的CPU部分资源被占用，其他线程无法进入，会增加时间限制。
	wait() 指线程处于进入等待状态，形象地说明为“等待使用CPU”，此时线程不占用任何资源，不增加时间限制。

> 自旋锁和自适应自旋

	自旋锁： 
		为了让线程等待，让线程执行一个忙循环【自旋】。
		JDK1.6后默认处于开启状态。
		由于自旋占用处理器时间，所以自旋等待时间需要有个度，默认自旋次数为10次。

	自适应自旋：
		自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间和锁的拥有者的状态来决定。

> synchronized、Lock、ReentrantLock、ReadWriteLock

	synchronized 	隐式锁，不可中断

	Lock 显式锁接口			

		Lock是一个接口，定义了一些抽象的所操作。
		与内部锁机制不同，Lock提供了无条件，可轮询，定时的，可中断的锁获取操作，所有加锁和解锁的方法都是显式的。
		锁必须在finally块中释放。

	ReentrantLock 	
	
		可重入锁，可中断锁，默认是非公平锁，也可以指定为公平锁。
		ReentranLock实现了Lock接口，提供了与synchronized相同的互斥和内存可见性的保证。
		获得ReentrantLock的锁与进入synchronized块有着相同内存含义，释放ReentrantLock锁与退出synchronized块有着相同内存含义。
		
	ReadWriteLock 	

		读写锁
		synchronized 可以完成的 ReentranLock 都能完成，反之不成立。

> 介绍下CAS(无锁技术)。

	比较并交换 - compare and swap
	CAS 需要三个操作数：内存地址值，旧的预期值，新值。

	执行过程：
		当且仅当 内存地址 中的值为 旧的预期值 时，处理器才会使用 新值 更换内存地址中的值，否则不执行更换。
		但是不管是否更换值，都会返回 内存地址 的旧值。

	CAS 的执行过程是一个原子操作。

	缺点："ABA"问题。

> ThreadLocal

	线程本地存储，无须同步也能保证线程安全。

	使用 ThreadLocal 类来实现线程本地存储的功能。
	每个线程的 Thread 对象都有一个 ThreadLocalMap 对象，该对象以 ThreadLocal.threadLocalHashCode 为键，以本地线程保存的变量为值。

	ThreadLocal 对象就是当期线程的 ThreadLocalMap 的访问入口，通过唯一的 threadLocalHashCode 值就可以获取 本地线程变量。

	将共享的变量拷贝到每个线程的工作内存的变量副本，这样就不会产生竞争问题了，使用空间换时间的思路。

> 创建线程池的4种方式

	Executors.newCachedThreadPool();        //创建一个线程池，线程池容量大小为Integer.MAX_VALUE

	Executors.newSingleThreadExecutor();   	//创建容量为1的线程池

	Executors.newFixedThreadPool(int);    	//创建固定容量大小的线程池

	Executors.newScheduledThreadPool(int)	//创建定时任务的线程池

> ThreadPoolExecutor的内部工作原理

	1. 查看当前运行状态，如果不是RUNNING状态，将直接拒绝新任务。
		否则进入步骤2。
	
	2. 查看当前运行线程的数量，如果数量少于核心线程数，将直接创建新的线程执行该任务。
		否则进入步骤3。
	
	3. 将该任务添加到阻塞队列，等待核心线程执行完上一个任务再来获取。
		如果添加到阻塞队列失败，进入步骤4。
	
	4. 尝试创建一个非核心线程执行该任务，前提是线程的数量少于等于最大线程数。
		如果失败，拒绝该任务。

> 分布式环境下，怎么保证线程安全

	通过 mysql、redis、zookeeper 处理分布式锁。

> 分布式session存储解决方案

	session 统一保存在redis集群中。
	使用Spring-Session 保存session。