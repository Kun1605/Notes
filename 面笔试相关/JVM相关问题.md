### JVM相关问题 ###

> 介绍下垃圾收集机制

	可达分析法：在对象没有引用链相连时，垃圾收集器会对该对象进行回收。

> Java 中的4种引用

	判定对象是否存活都和引用有关。
	
	希望一类对象再内存足够时还能保留在内存中，只有当内存紧张时才会抛弃这些对象。	
	
	1. 强引用：
		类似 Object obj = new Object(); 这类引用。
		只要强引用还存在，垃圾收集器永远不会回收这些被引用的对象。
	
	2. 软引用：
		用来描述一些还有用，但并非必须的对象。
		只有当虚拟机的内存准备溢出时，才会将这些引用对象进行第二次回收。
	
		软引用可用来实现内存敏感的高速缓存。
	
	3. 弱引用：
		用来描述非必需的对象，比软引用更弱。
		该引用的对象只能生存到下一次垃圾回收发生之前，即无论内存是否足够，该引用对象都会被回收。
	
	4. 虚引用：
		最弱的引用。
		一个对象是否用虚引用，完全不会影响其生存时间，也无法通过虚引用来获取对象实例。
		该引用的唯一目的：希望能在该对象被回收时收到一个系统通知。

> 内存模型以及分区，需要详细到每个区放什么

	内存的5个主要分区：
	1. 程序计数器：
	
		代表当期线程所执行的字节码的行号指示器。
		属于线程私有内存。
		每个线程都有独立的计数器，确保线程切换后能恢复到正确的执行位置。
		由于需要的内存空间很小，所有该区域是唯一一个在JVM中没有 OutOfMemoryError 的区域。
	
	2. Java虚拟机栈
	
		属于线程私有。
		生命周期和线程相同。
		每个方法被执行时都会同时创建一个栈帧【方法运行期的基础数据结构】，用来储存局部变量表等信息。
		每个方法被调用直至执行完成的过程就是一个栈帧在虚拟机栈中从入栈到出栈的过程。
		
		该区域的两种异常情况：
		1. 若线程请求的栈深度大于虚拟机所允许的深度，就会抛出 StackOverflowError 异常；
		2. 若虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时，即需要的内存大于虚拟机的最大内存时，就会抛出 OutOfMemoryError 异常。
	
	3. 本地方法栈
	
		和Java虚拟机栈很类似。
		区别：虚拟机栈为虚拟机执行 Java方法【字节码】服务，本地方法栈在是为虚拟机使用到的 Native 方法服务。
		也会抛出 StackOverflowError 和 OutOfMemoryError 异常。
	
		有的虚拟机直接将本地方法栈和 Java虚拟机栈 合二为一，比如Sun HotSpot 虚拟机。
	
	4. Java 堆
	
		该区域是 Java虚拟机所管理的内存中最大的一块区域。
		属于线程共享的内存区域。
		唯一目的就是存放对象实例。
		Java 堆 也是垃圾收集器管理的主要区域，GC堆。
		Java 堆可以处于物理上不连续的内存空间，只要在逻辑上是连续的即可，类似硬盘空间。
		可通过 -Xmx 和 -Xms控制内存的扩展。
		内存不足时会抛出 OutOfMemoryError 异常。
	
	5. 方法区
	
		属于线程共享的内存区域。
		用来存放被虚拟机加载的类信息、常量、静态变量等数据。
		内存不足时会抛出 OutOfMemoryError 异常。
	
		Java 虚拟机规范对该区域的限制很宽松，致使垃圾收集行为在该区域很少出现。
		垃圾收集行为的目标主要是针对 常量池 的回收。
	
	5.1 运行时常量池
	
		是方法区的一部分。
		用来存放编译期生成的符号引用和各种字面量。
			int i = 1;	把整数1赋值给int型变量i，整数1就是Java字面量，
			同样，String s = "abc";	中的abc也是字面量。

> 堆里面的分区：Eden，survival from to，老年代，各自的特点。

	组成：Eden + Surviver（S0 + S1） + Old
	对象生命周期：Eden > Surviver（S0 + S1） > Old
	Eden【新生代】
		1、对象优先在新生代【Eden】区中分配。该区域是最主要的刚创建的对象的内存分配区域，绝大多数对象都会被创建到这里（除了部分大对象通过内存担保机制创建到Old区域，默认大对象都是能够存活较长时间的），故垃圾回收器针对该部分主要采用标记整理算法了回收该区域。
	    2、当 Eden 区没有足够的空间时，JVM将发起一次 Minor GC。
		3、标记整理算法
	Surviver【新生代的区域】
	    1、Surviver:该区域也是属于新生代的区域，该区域是将在Eden中未被清理的对象存放到该区域中，该区域分为两块区域，采用的是复制算法，每次只使用一块，Eden与Surviver区域的比例是8:1，是根据大量的业务运行总结出来的规律。
	
	Old【老年代】：
		1、一般能够在Surviver中没有被清除出去的对象才会进入到这块区域，该区域主要是采用标记清除算法。
		2、当没有足够的内存时，发起 Major GC，经常伴随着 Minor GC动作。
		3、Major GC 一般比 Minor GC 速度慢10倍以上。
		4、大对象【需要大量连续内存空间的Java对象】直接进入老年代。
		
		总结：java堆的垃圾回收是垃圾回收器最主要的光顾对象，整体采用分代收集的策略，对不同区域结合其特点采用不同的垃圾收集算法。我们在编程中也应该关注这一块区域，尽量不适用大对象，尽可能的创建局部对象，使用过后确定废弃不用的对象及时断开引用，尽量避免使用循环的对象引用（可达性分析也是比较消耗资源的）等等。

> ![image.png](https://camo.githubusercontent.com/5b7880816d2ef974be0e2901f783fc390d4471fc/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31323135392d646561666439353838623734613263662e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)对象创建方法，对象的内存分配，对象的访问定位。

	对象创建：
	Object obj = new Object(); 
		1. obj 保存在虚拟机栈局部变量表中，作为引用数据使用；
		2. new Object() 在Java堆中分配一个存储Object类型的所有数据的结构内存。


​	
	根据 具体类型 以及 虚拟机实现的对象内存分布 进行内存大小的分配，内存大小不固定。
	对象优先在新生代【Eden】区中分配。
	
	主流的访问方式：
	
		1. 使用句柄【常用】：
			在Java堆中划分一块内存作为句柄池，引用数据中存储的就是对象的句柄地址，比如Object obj。
			优点：当对象被移动时只需要修改句柄的指针，对象的引用数据本身不需要被修改。
	 
		2. 直接指针：
			引用数据中存储的就是对象的地址。
			优点：速度快，节省一次指针定位的时间开销。

> 判定对象是否存活。

	可达分析法：
	
		通过一系列名为"GC Roots" 的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为 引用链【Reference Chain】，当一个对象到 GC Roots 都没有任何引用链相连时，则证明该对象是不可用的。
		不可用的对象即被判定位可回收对象。
	
		可作为 GC Roots 的对象：
			1. 虚拟机栈中引用的对象；
			2. 方法区中静态变量引用的对象；
			3. 方法区中常量引用的对象；
			4. 本地方法栈中引用的对象。

> GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？

	1. 标记 - 清除算法
	
		首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。
		缺点：
			1. 效率低；
			2. 会产生大量不连续的内存空间。
			
	2. 复制算法
	
		将可用内存按容量划分为大小相等的两块，每次只使用一块。
		当这一块准备用完时，将还存活的对象复制到另一块上，然后一次性清理已使用的内存空间。
	
		少量对象存活时，效率高；大量存活时效率就低下了。
		缺点：浪费一半的空间。
	
	3. 标记 - 整理算法
	
		标记过程和 “标记 - 清除”算法一样，但标记后不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后清理掉边界以外的内存。
	
	4. 分代收集算法
	
		根据对象的存活周期的不同，将内存划分为几块。
		将Java堆分为新生代和老年代，根据年代的特点进行适当的回收算法。
		比如，在新生代中只有少量存活，可以使用 复制算法进行回收；
		老年代中有大量存活，则必须使用 “标记-清理” 或者 “标记-整理”算法进行回收。

> GC收集器有哪些？CMS收集器与G1收集器的特点。

	CMS收集器：
		是一种以最短回收停顿时间为目标的收集器。
		基于 “标记 - 清除” 算法实现的收集器
	
	G1收集器 比 CMS收集器 有了2个显著改进：
	1. G1收集器是基于 “标记 - 整理” 算法实现的收集器，即不会产生空间碎片。
	2. 可以精确的控制停顿，减少在垃圾收集上的时间消化。

> Minor GC与Full GC分别在什么时候发生？

	Minor GC 发生在新生代；
	Full GC 发生在老年代。

> 几种常用的内存调试工具：

	jps: 显示指定系统内所有的虚拟机进程状况；
	
	jstat: 显示虚拟机统计信息
	
	jstack:	显示虚拟机的线程快照，用于跟踪Java堆栈，定位线程出现长时间停顿的原因；
	
	jmap: 生成虚拟机的内存存储快照【heapdump文件】
	
	jinfo: 显示虚拟机配置信息
	
	jconsole：JDK的可视化工具，Java监视和管理控制台

> 类加载的过程：

	1. 加载
	
		1. 通过一个类的全限定名来获取定义该类的二进制字节流； 
		2. 将该字节流所代表的静态存储结构转为方法区的运行时数据结构【栈帧】；
		3. 在Java堆中生成一个代表该类的 java.lang.Class 对象，作为方法区中这些数据的访问入口。
	
		通过反射的 Class.forName(全类名) 创建 Class 对象。
		可以由JVM的类加载器加载，也可以由自定义的类加载器加载。
		
	2. 验证
	
		目的：确保Class 文件的字节流中包含的信息符合当前虚拟机的要求，不会危害虚拟机自身安全。
		大致验证过程：
			1. 文件格式验证；
			2. 元数据验证；
			3. 字节码验证；
			4. 符号引用验证。
			
	3. 准备
	
		为静态变量分配内存，并设置静态变量初始值【零值】。
		【注】只是设置初始值，并没有进行赋值。
			通常情况下，初始值是数据类型的零值。
	
		比如： public static int value = 123;
		该阶段过后的value的初始值为0，而不是123。
	
	4. 解析
	
		虚拟机将常量池内的符号引用替换为直接引用的过程。
			即将代码中引用的符号转为实际的入口地址。
	
		1. 符号引用：
			以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。
			符号引用和JVM实现的内存布局无关，引用的目标并不一定已经加载到内存中。
	
			在Java中，一个Java类将会编译成一个class文件。
			在编译时，Java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。
			包括了如下三种类型的常量：
	
				1. 类和接口的全限定名
				2. 字段名称和描述符
				3. 方法名称和描述符
	
		2. 直接引用：
			可以是直接指向目标的指针、相对偏移量、能间接定位到目标的句柄。
			和JVM实现的布局相关，引用的目标一定已经加载到内存中。
			实际的入口地址。
	
		解析动作主要是针对类或接口、字段、类方法、接口方法这四类符号引用。
	
	5. 初始化
	
		开始执行类中定义的Java字节码，对变量进行赋值等操作。

> 类加载器

	作用：通过一个类的全限定名来获取描述该类的二进制字节流。
	
	虚拟机的类加载机制：
		虚拟机把描述类的数据从Class文件【一串二进制字节流】中加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。
	
	确定加载的类的唯一性：需要由加载它的类加载器和该类本身一起确认。
		
	比较两个类是否相等，前提是这两个类都是由同一个类加载器加载。
	否则即使是同一个类不同的类加载器加载后，也会不相等。
	
	Java虚拟机主要有两种类加载器：启动类加载器、用户自定义类加载器。
	
	用户自定义的类加载器是普通的Java对象，该类必须派生自java.lang.ClassLoader 类。
	ClassLoader类提供了访问类加载器的接口 loadClass。

> 双亲委派模型：

	将类的加载动作交给自己的父类进行完成，除非父类无法完成这个加载请求【没有找到所需的类】时，子加载器才会自己去加载。
	
	确保java的核心类都是由启动类加载器加载，保证类的安全性，比如Object、String类。	
	
	启动类加载器【Bootstrap ClassLoader】
		负责加载$JAVA_HOME/lib下的jar包和class文件
	
	扩展类加载器【Extension ClassLoader】
		负责加载$JAVA_HOME/lib/ext下的jar包和class文件
	
	应用程序类加载器【ApplicationClassLoader】
		负责加载classpath下的jar包和class文件

![](images/jvm1.png)

> 能不能自己写一个类叫java.lang.String

	不能，由于双亲委托机制，使得String的加载交给了父类加载器【启动类加载器】

> 分派：静态分派与动态分派

	体现了多态的特性--重载、重写。
	
	静态分派
	
		指的是所有依赖静态类型来定位方法执行版本的分派动作。
		最典型的应用就是 方法重载 overload；
	
		发生在编译阶段
	
	动态分派
	
		指的是运行期根据实际类型确定方法执行版本的分派动作。
		最典型的应用就是 方法重写 override。

推荐书籍：《深入理解java虚拟机》